<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_2_1.xsd"
                 version="2.1">

    <package>com.witness.server.entity</package>

    <!--
    We introduce a dissonance in ID generation between production and test executions. Hibernate's @SequenceGenerator
    annotation, which is implemented via SequenceStyleGenerator.java, uses a pooled approach of generating
    new IDs based on the annotation's allocationSize attribute in order to reduce database round trips. For instance, an
    allocation-size of 50 means that Hibernate increases the database sequence value by 50, increments a local ID
    counter (used the return newly generated IDs) for the next 50 inserts and only at the 51st insert, increments the
    database sequence again.

    We do not want to lose this performance gain for in production, but need the database sequence to be in sync with
    the SequenceStyleGenerator in order to predict IDs for test purposes (e.g. foreign keys in JSON test data etc.). One
    important aspect is that, with an allocation-size greater than one, we cannot simply reset the database sequence
    in between tests because Hibernate's SequenceStyleGenerator's internal counter cannot be reset. Therefore, IDs would
    still increase in between tests despite resetting the database sequence. This would lead to the IDs generated by the
    repository during tests dependent on the order of test executions, which is fatal.

    A solution would be to to extract the generated IDs after persisting IDs via a repository. Then, we would need to
    set exactly those IDs returned by the repositories in other entities that need them as foreign keys. However, this
    would make the test code much less readable as well as the JSON test sources less self-contained.

    In order to both keep the performance gain in production as well as have predictable IDs (by being able to simply
    reset the sequence counter) during tests, we override the allocation size of entity ID sequences to be exactly one.
    This solves the problems described above since it implies that the SequenceStyleGenerator's internal count is
    always in sync with the actual database sequence.

    Note: The attribute mappings below are additive, i.e. they do not disrupt or clear mappings of other entity
    attributes that are defined via annotations in the production code.
    -->

    <entity class="User">
        <attributes>
            <id name="id">
                <generated-value strategy="SEQUENCE" generator="user_id_generator"/>
                <sequence-generator name="user_id_generator" sequence-name="user_id_sequence" allocation-size="1"/>
            </id>
        </attributes>
    </entity>

    <entity class="Exercise">
        <attributes>
            <id name="id">
                <generated-value strategy="SEQUENCE" generator="exercise_id_generator"/>
                <sequence-generator name="exercise_id_generator" sequence-name="exercise_id_sequence"
                                    allocation-size="1"/>
            </id>
        </attributes>
    </entity>

</entity-mappings>